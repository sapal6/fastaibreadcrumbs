# AUTOGENERATED! DO NOT EDIT! File to edit: ../00_core.ipynb.

# %% auto 0
__all__ = ['pixel_loss', 'setup_data', 'Crappifier', 'get_unet_dls', 'gram_matrix', 'FeatureLoss', 'get_ft_model', 'calc_ft_loss']

# %% ../00_core.ipynb 4
from fastai.vision.all import *
from fastkaggle import *

# %% ../00_core.ipynb 6
def setup_data(user: str, dataset: str, install=''):
    "Get a path to data for the `user's` `dataset`, downloading it if needed"
    if iskaggle:
        if install:
            os.system(f'pip install -Uqq {install}')
        return Path('../input')/dataset
    else:
        path = Path(dataset)
        from kaggle import api
        if not path.exists():
            api.dataset_download_cli(f'{user}/{dataset}', path=str(path), unzip=True)
        return path

# %% ../00_core.ipynb 9
class Crappifier:
    """class to crappify images"""
    def __init__(self, path_hr, path_crappy):
        self.cvmodule = __import__('cv2')
        self.path_hr = path_hr
        self.path_crappy = path_crappy

    def __apply_motion_blur(self, img: Path, sz: int, angle: int):
        """apply motion blur in images at the givn angle and size of blur lines"""
        k = np.zeros((sz, sz), dtype=np.float32)
        k[ (sz-1)// 2 , :] = np.ones(sz, dtype=np.float32)
        k = self.cvmodule.warpAffine(k, self.cvmodule.getRotationMatrix2D( (sz / 2 -0.5 , sz / 2 -0.5 ) , angle, 1.0), (sz, sz) )  
        k = k * ( 1.0 / np.sum(k) )        
        return self.cvmodule.filter2D(img, -1, k) 

    def __call__(self, fn: Path):
        """apply motion blur on images"""
        dest = self.path_crappy/fn.relative_to(self.path_hr)
        dest.parent.mkdir(parents=True, exist_ok=True)
        img = self.cvmodule.imread(str(fn))
        img = self.__apply_motion_blur(img, 30, 0)
        self.cvmodule.imwrite(str(dest), img)

# %% ../00_core.ipynb 17
def get_unet_dls(bs:int,  source=None,
                  blocks: tuple=(ImageBlock, ImageBlock), dl_type=None, getters=None,
                  n_inp=None, get_items=None, get_y=None, get_x=None, splitter=None,
                  item_tfms=None, batch_tfms=None, **kwargs):
    """function to create the datablock and the dataloader for Unet"""
    dblock = DataBlock(blocks=blocks,
                       dl_type=dl_type,
                       getters=getters,
                       n_inp=n_inp,
                       get_items=None,
                       get_x=get_x,
                       get_y=get_y,
                       splitter=splitter,
                       item_tfms=item_tfms,
                       batch_tfms=batch_tfms)

    dls=dblock.dataloaders(source, bs=bs, **kwargs)
    dls.c=3
    
    return dls

# %% ../00_core.ipynb 22
def gram_matrix(x):
    """function to calculate the gram matrix"""
    n,c,h,w = x.size()
    x = x.view(n, c, -1)
    return (x @ x.transpose(1,2))/(c*h*w)

# %% ../00_core.ipynb 23
pixel_loss = F.l1_loss

# %% ../00_core.ipynb 24
class FeatureLoss(nn.Module):
    """class to calculate feature loss"""
    def __init__(self, m_feat, layer_ids, layer_wgts):
        super().__init__()
        self.m_feat = m_feat
        self.loss_features = [self.m_feat[i] for i in layer_ids]
        self.hooks = hook_outputs(self.loss_features, detach=False)
        self.wgts = layer_wgts
        self.metric_names = ['pixel',] + [f'feat_{i}' for i in range(len(layer_ids))
              ] + [f'gram_{i}' for i in range(len(layer_ids))]

    def make_features(self, x, clone=False):
        """gather the feature maps and store them"""
        self.m_feat(x)
        return [(o.clone() if clone else o) for o in self.hooks.stored]
    
    def forward(self, input, target):
        """calculate the feature losses and store in list"""
        out_feat = self.make_features(target, clone=True)
        in_feat = self.make_features(input)
        self.feat_losses = [pixel_loss(input,target)]
        self.feat_losses += [pixel_loss(f_in, f_out)*w
                             for f_in, f_out, w in zip(in_feat, out_feat, self.wgts)]
        self.feat_losses += [pixel_loss(gram_matrix(f_in), gram_matrix(f_out))*w**2 * 5e3
                             for f_in, f_out, w in zip(in_feat, out_feat, self.wgts)]
        self.metrics = dict(zip(self.metric_names, self.feat_losses))
        return sum(self.feat_losses)
    
    def __del__(self): self.hooks.remove()

# %% ../00_core.ipynb 26
def get_ft_model(pretrained=True):
    """prepare a model for feature extraction"""
    from torchvision.models import vgg16
    
    ft_model = vgg16(pretrained=pretrained).features.cuda().eval()
    for p in ft_model.parameters(): p.requires_grad_(False)
    return ft_model

# %% ../00_core.ipynb 28
def calc_ft_loss(pretrained=True):
    """calculate the feature loss using the given architecture"""
    ft_model = get_ft_model(pretrained)
    blocks = [i-1 for i,o in enumerate(ft_model.children()) if isinstance(o,nn.MaxPool2d)]
    return FeatureLoss(ft_model, blocks[2:5], [5,15,2])
